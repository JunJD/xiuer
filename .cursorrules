# å°çº¢ä¹¦æ•°æ®åˆ†æå¹³å° - Cursor Rules

You are an expert full-stack developer proficient in **Python 3.12**, **FastAPI**, **Next.js 14**, **TypeScript**, **PostgreSQL**, **Docker**, and modern web development best practices.

## ğŸ¯ Core Expertise
- Backend: FastAPI + AsyncSQLAlchemy + Pydantic v2 + Alembic
- Frontend: Next.js 14 (App Router) + TypeScript + Tailwind CSS + React Query + Zustand
- Database: PostgreSQL + Redis (caching)
- DevOps: Docker + GitHub Actions + MkDocs
- Crawler: Python + PyExecJS + Loguru
- Testing: pytest + Jest + React Testing Library

## ğŸ“ Monorepo Structure

```
project_root/
â”œâ”€â”€ fastapi_backend/         # FastAPI åç«¯æœåŠ¡
â”‚   â”œâ”€â”€ app/
â”‚   â”‚   â”œâ”€â”€ core/           # æ ¸å¿ƒé…ç½® (config, database, logger)
â”‚   â”‚   â”œâ”€â”€ models.py       # SQLAlchemy ORM æ¨¡å‹
â”‚   â”‚   â”œâ”€â”€ schemas/        # Pydantic æ•°æ®æ¨¡å‹
â”‚   â”‚   â”œâ”€â”€ services/       # ä¸šåŠ¡é€»è¾‘å±‚
â”‚   â”‚   â”œâ”€â”€ routes/         # API è·¯ç”±å±‚
â”‚   â”‚   â””â”€â”€ main.py         # FastAPI åº”ç”¨å…¥å£
â”‚   â”œâ”€â”€ tests/              # åç«¯æµ‹è¯•
â”‚   â”œâ”€â”€ alembic/            # æ•°æ®åº“è¿ç§»
â”‚   â””â”€â”€ pyproject.toml
â”œâ”€â”€ nextjs-frontend/         # Next.js å‰ç«¯åº”ç”¨
â”‚   â”œâ”€â”€ app/                # App Router é¡µé¢
â”‚   â”œâ”€â”€ components/         # UI ç»„ä»¶
â”‚   â”œâ”€â”€ lib/                # å·¥å…·åº“å’Œ hooks
â”‚   â””â”€â”€ __tests__/          # å‰ç«¯æµ‹è¯•
â”œâ”€â”€ Spider_XHS/              # å°çº¢ä¹¦çˆ¬è™«ç³»ç»Ÿ
â”‚   â”œâ”€â”€ apis/               # API æ¥å£å°è£…
â”‚   â”œâ”€â”€ xhs_utils/          # çˆ¬è™«å·¥å…·å‡½æ•°
â”‚   â”œâ”€â”€ src/                # æ ¸å¿ƒçˆ¬è™«ä»£ç 
â”‚   â”œâ”€â”€ main.py             # çˆ¬è™«å…¥å£
â”‚   â””â”€â”€ pyproject.toml
â”œâ”€â”€ docs/                   # MkDocs æ–‡æ¡£
â”œâ”€â”€ .github/workflows/      # GitHub Actions
â”œâ”€â”€ docker-compose.yml      # å¼€å‘ç¯å¢ƒ
â””â”€â”€ mkdocs.yml             # æ–‡æ¡£é…ç½®
```

## ğŸ—ï¸ Architecture Principles

### Backend (FastAPI)
- **åˆ†å±‚æ¶æ„**: Routes â†’ Services â†’ Models
- **ä¾èµ–æ³¨å…¥**: ä½¿ç”¨ FastAPI çš„ Dependency Injection
- **å¼‚æ­¥ä¼˜å…ˆ**: æ‰€æœ‰æ•°æ®åº“æ“ä½œä½¿ç”¨ AsyncSession
- **ç±»å‹å®‰å…¨**: ä¸¥æ ¼çš„ Pydantic æ•°æ®éªŒè¯
- **é”™è¯¯å¤„ç†**: ç»Ÿä¸€çš„ HTTPException å¤„ç†

### Frontend (Next.js)
- **App Router**: ä½¿ç”¨ Next.js 14 æœ€æ–°è·¯ç”±ç³»ç»Ÿ
- **æœåŠ¡ç«¯ç»„ä»¶**: ä¼˜å…ˆä½¿ç”¨ RSCï¼Œå¿…è¦æ—¶æ‰ç”¨å®¢æˆ·ç«¯ç»„ä»¶
- **ç±»å‹å®‰å…¨**: TypeScript strict mode + Zod éªŒè¯
- **çŠ¶æ€ç®¡ç†**: Zustand (å…¨å±€) + React Query (æœåŠ¡ç«¯çŠ¶æ€)
- **æ ·å¼ç³»ç»Ÿ**: Tailwind CSS + CSS Modules

### Spider (Python)
- **å¼‚æ­¥çˆ¬å–**: ä½¿ç”¨ asyncio æå‡æ€§èƒ½
- **é”™è¯¯é‡è¯•**: å†…ç½®é‡è¯•æœºåˆ¶å’Œå®¹é”™å¤„ç†
- **æ•°æ®ç®¡é“**: çˆ¬å– â†’ æ¸…æ´— â†’ å­˜å‚¨ â†’ Webhook é€šçŸ¥
- **ååçˆ¬**: åŠ¨æ€ User-Agent + è¯·æ±‚é—´éš”æ§åˆ¶

## ğŸ’» Code Style Guidelines

### Python (Backend & Spider)
```python
# æ–‡ä»¶ç»“æ„ç¤ºä¾‹: app/services/note_service.py
from __future__ import annotations

from datetime import datetime
from typing import Optional
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from app.models import XhsNote, User
from app.schemas.note import NoteCreate, NoteUpdate
from app.core.logger import app_logger as logger


class NoteService:
    """å°çº¢ä¹¦ç¬”è®°æœåŠ¡å±‚"""
    
    def __init__(self, db: AsyncSession) -> None:
        self.db = db
    
    async def create_note(
        self, 
        note_data: NoteCreate, 
        user_id: int
    ) -> XhsNote:
        """åˆ›å»ºæ–°ç¬”è®°"""
        note = XhsNote(
            **note_data.model_dump(),
            user_id=user_id,
            created_at=datetime.utcnow()
        )
        self.db.add(note)
        await self.db.commit()
        await self.db.refresh(note)
        
        logger.info(f"Created note {note.note_id} for user {user_id}")
        return note
    
    async def get_note_by_id(self, note_id: str) -> Optional[XhsNote]:
        """æ ¹æ®IDè·å–ç¬”è®°"""
        stmt = select(XhsNote).where(XhsNote.note_id == note_id)
        result = await self.db.execute(stmt)
        return result.scalar_one_or_none()
```

### TypeScript (Frontend)
```typescript
// æ–‡ä»¶ç»“æ„ç¤ºä¾‹: lib/api/notes.ts
import { z } from 'zod'

// ç±»å‹å®šä¹‰
export const NoteSchema = z.object({
  noteId: z.string(),
  title: z.string().min(1).max(100),
  content: z.string().min(1),
  tags: z.array(z.string()).optional(),
  publishedAt: z.string().datetime(),
})

export type Note = z.infer<typeof NoteSchema>

// API å®¢æˆ·ç«¯
export class NotesApi {
  private baseUrl: string

  constructor(baseUrl: string) {
    this.baseUrl = baseUrl
  }

  async getNotes(params?: {
    page?: number
    limit?: number
    tag?: string
  }): Promise<Note[]> {
    const searchParams = new URLSearchParams()
    if (params?.page) searchParams.set('page', params.page.toString())
    if (params?.limit) searchParams.set('limit', params.limit.toString())
    if (params?.tag) searchParams.set('tag', params.tag)

    const response = await fetch(`${this.baseUrl}/notes?${searchParams}`)
    if (!response.ok) {
      throw new Error(`Failed to fetch notes: ${response.statusText}`)
    }

    const data = await response.json()
    return z.array(NoteSchema).parse(data)
  }
}
```

### React Components
```tsx
// æ–‡ä»¶ç»“æ„ç¤ºä¾‹: components/NoteCard.tsx
'use client'

import { useState } from 'react'
import { useMutation, useQueryClient } from '@tanstack/react-query'
import { Card, CardHeader, CardContent } from '@/components/ui/card'
import { Button } from '@/components/ui/button'
import type { Note } from '@/lib/api/notes'

interface NoteCardProps {
  note: Note
  onEdit?: (noteId: string) => void
  onDelete?: (noteId: string) => void
}

export function NoteCard({ note, onEdit, onDelete }: NoteCardProps) {
  const [isLoading, setIsLoading] = useState(false)
  const queryClient = useQueryClient()

  const deleteMutation = useMutation({
    mutationFn: async (noteId: string) => {
      const response = await fetch(`/api/notes/${noteId}`, {
        method: 'DELETE',
      })
      if (!response.ok) throw new Error('Failed to delete note')
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['notes'] })
    },
  })

  const handleDelete = async () => {
    if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™æ¡ç¬”è®°å—ï¼Ÿ')) return
    
    setIsLoading(true)
    try {
      await deleteMutation.mutateAsync(note.noteId)
      onDelete?.(note.noteId)
    } finally {
      setIsLoading(false)
    }
  }

  return (
    <Card className="w-full max-w-sm">
      <CardHeader>
        <h3 className="font-semibold text-lg line-clamp-2">
          {note.title}
        </h3>
      </CardHeader>
      <CardContent className="space-y-4">
        <p className="text-sm text-muted-foreground line-clamp-3">
          {note.content}
        </p>
        
        {note.tags && note.tags.length > 0 && (
          <div className="flex flex-wrap gap-1">
            {note.tags.map(tag => (
              <span 
                key={tag}
                className="px-2 py-1 bg-primary/10 text-primary text-xs rounded-full"
              >
                #{tag}
              </span>
            ))}
          </div>
        )}
        
        <div className="flex justify-between pt-2">
          <Button 
            variant="outline" 
            size="sm"
            onClick={() => onEdit?.(note.noteId)}
          >
            ç¼–è¾‘
          </Button>
          <Button 
            variant="destructive" 
            size="sm"
            disabled={isLoading}
            onClick={handleDelete}
          >
            {isLoading ? 'åˆ é™¤ä¸­...' : 'åˆ é™¤'}
          </Button>
        </div>
      </CardContent>
    </Card>
  )
}
```

## ğŸ”§ Development Rules

### Naming Conventions
- **æ–‡ä»¶å**: `snake_case.py` (Python), `kebab-case.ts` (å·¥å…·), `PascalCase.tsx` (ç»„ä»¶)
- **å˜é‡/å‡½æ•°**: `snake_case` (Python), `camelCase` (TypeScript)
- **ç±»å**: `PascalCase` (æ‰€æœ‰è¯­è¨€)
- **å¸¸é‡**: `UPPER_SNAKE_CASE` (æ‰€æœ‰è¯­è¨€)
- **æ•°æ®åº“è¡¨**: `snake_case` å¤æ•°å½¢å¼ (å¦‚ `xhs_notes`)

### Import Organization
```python
# Python å¯¼å…¥é¡ºåº
from __future__ import annotations

# æ ‡å‡†åº“
import asyncio
from datetime import datetime
from typing import Optional

# ç¬¬ä¸‰æ–¹åº“
from fastapi import HTTPException
from sqlalchemy import select

# æœ¬åœ°å¯¼å…¥
from app.core.logger import app_logger as logger
from app.models import XhsNote
```

```typescript
// TypeScript å¯¼å…¥é¡ºåº
// React ç›¸å…³
import { useState, useEffect } from 'react'
import { NextRequest, NextResponse } from 'next/server'

// ç¬¬ä¸‰æ–¹åº“
import { z } from 'zod'
import { clsx } from 'clsx'

// æœ¬åœ°å¯¼å…¥
import { Button } from '@/components/ui/button'
import { NotesApi } from '@/lib/api/notes'
import type { Note } from '@/types/note'
```

### Error Handling
```python
# åç«¯é”™è¯¯å¤„ç†
from fastapi import HTTPException, status

# ä¸šåŠ¡é€»è¾‘é”™è¯¯
raise HTTPException(
    status_code=status.HTTP_400_BAD_REQUEST,
    detail="ç¬”è®°ä¸å­˜åœ¨æˆ–å·²è¢«åˆ é™¤"
)

# æƒé™é”™è¯¯
raise HTTPException(
    status_code=status.HTTP_403_FORBIDDEN,
    detail="æ— æƒé™è®¿é—®è¯¥èµ„æº"
)
```

```typescript
// å‰ç«¯é”™è¯¯å¤„ç†
try {
  const response = await fetch('/api/notes')
  if (!response.ok) {
    throw new Error(`HTTP ${response.status}: ${response.statusText}`)
  }
  return await response.json()
} catch (error) {
  console.error('è·å–ç¬”è®°å¤±è´¥:', error)
  toast.error('è·å–æ•°æ®å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•')
  throw error
}
```

## ğŸ“ Documentation with MDC

### API æ–‡æ¡£ (MDCæ ¼å¼)
```markdown
::api-endpoint{method="POST" path="/api/notes"}
åˆ›å»ºæ–°ç¬”è®°

#request
```json
{
  "title": "ç¬”è®°æ ‡é¢˜",
  "content": "ç¬”è®°å†…å®¹",
  "tags": ["æ ‡ç­¾1", "æ ‡ç­¾2"]
}
```

#response
```json
{
  "noteId": "note_123",
  "title": "ç¬”è®°æ ‡é¢˜",
  "content": "ç¬”è®°å†…å®¹",
  "tags": ["æ ‡ç­¾1", "æ ‡ç­¾2"],
  "createdAt": "2024-01-01T00:00:00Z"
}
```
::

### ç»„ä»¶æ–‡æ¡£ (MDCæ ¼å¼)
```markdown
::component-demo
---
component: NoteCard
props:
  note:
    noteId: "note_123"
    title: "ç¤ºä¾‹ç¬”è®°"
    content: "è¿™æ˜¯ä¸€ä¸ªç¤ºä¾‹ç¬”è®°å†…å®¹"
    tags: ["React", "TypeScript"]
---
::

### Props

::props-table
| å±æ€§ | ç±»å‹ | å¿…éœ€ | é»˜è®¤å€¼ | æè¿° |
|------|------|------|--------|------|
| note | Note | âœ“ | - | ç¬”è®°æ•°æ®å¯¹è±¡ |
| onEdit | (noteId: string) => void | âœ— | - | ç¼–è¾‘å›è°ƒå‡½æ•° |
| onDelete | (noteId: string) => void | âœ— | - | åˆ é™¤å›è°ƒå‡½æ•° |
::
```

## ğŸ§ª Testing Standards

### Backend Tests
```python
# tests/services/test_note_service.py
import pytest
from unittest.mock import AsyncMock

from app.services.note_service import NoteService
from app.schemas.note import NoteCreate


@pytest.mark.asyncio
async def test_create_note_success():
    """æµ‹è¯•æˆåŠŸåˆ›å»ºç¬”è®°"""
    # Arrange
    mock_db = AsyncMock()
    service = NoteService(mock_db)
    note_data = NoteCreate(
        title="æµ‹è¯•ç¬”è®°",
        content="æµ‹è¯•å†…å®¹"
    )
    
    # Act
    result = await service.create_note(note_data, user_id=1)
    
    # Assert
    assert result.title == "æµ‹è¯•ç¬”è®°"
    assert result.user_id == 1
    mock_db.add.assert_called_once()
    mock_db.commit.assert_called_once()
```

### Frontend Tests
```typescript
// __tests__/components/NoteCard.test.tsx
import { render, screen, fireEvent, waitFor } from '@testing-library/react'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { NoteCard } from '@/components/NoteCard'

const mockNote = {
  noteId: 'note_123',
  title: 'æµ‹è¯•ç¬”è®°',
  content: 'æµ‹è¯•å†…å®¹',
  tags: ['æµ‹è¯•'],
  publishedAt: '2024-01-01T00:00:00Z'
}

describe('NoteCard', () => {
  let queryClient: QueryClient

  beforeEach(() => {
    queryClient = new QueryClient({
      defaultOptions: { queries: { retry: false } }
    })
  })

  it('should render note information correctly', () => {
    render(
      <QueryClientProvider client={queryClient}>
        <NoteCard note={mockNote} />
      </QueryClientProvider>
    )

    expect(screen.getByText('æµ‹è¯•ç¬”è®°')).toBeInTheDocument()
    expect(screen.getByText('æµ‹è¯•å†…å®¹')).toBeInTheDocument()
    expect(screen.getByText('#æµ‹è¯•')).toBeInTheDocument()
  })

  it('should call onEdit when edit button is clicked', () => {
    const onEdit = jest.fn()
    
    render(
      <QueryClientProvider client={queryClient}>
        <NoteCard note={mockNote} onEdit={onEdit} />
      </QueryClientProvider>
    )

    fireEvent.click(screen.getByText('ç¼–è¾‘'))
    expect(onEdit).toHaveBeenCalledWith('note_123')
  })
})
```

## ğŸš€ Performance & Security

### Database Optimization
- ä½¿ç”¨æ•°æ®åº“ç´¢å¼•ä¼˜åŒ–æŸ¥è¯¢æ€§èƒ½
- å®ç°åˆ†é¡µå’Œæ‡’åŠ è½½é¿å…å¤§æ•°æ®é›†
- ä½¿ç”¨ Redis ç¼“å­˜çƒ­ç‚¹æ•°æ®
- æ•°æ®åº“è¿æ¥æ± ç®¡ç†

### Frontend Optimization
- ä½¿ç”¨ Next.js çš„ Image ç»„ä»¶ä¼˜åŒ–å›¾ç‰‡
- å®ç°è™šæ‹Ÿæ»šåŠ¨å¤„ç†å¤§åˆ—è¡¨
- ä»£ç åˆ†å‰²å’Œæ‡’åŠ è½½ç»„ä»¶
- ä½¿ç”¨ React.memo å’Œ useMemo ä¼˜åŒ–æ¸²æŸ“

### Security Best Practices
- è¾“å…¥éªŒè¯å’Œ SQL æ³¨å…¥é˜²æŠ¤
- JWT token å®‰å…¨å­˜å‚¨å’Œåˆ·æ–°
- CORS å’Œ CSRF é˜²æŠ¤
- æ•æ„Ÿæ•°æ®åŠ å¯†å­˜å‚¨

## ğŸ“Š Logging & Monitoring

```python
# ç»Ÿä¸€æ—¥å¿—æ ¼å¼
from app.core.logger import app_logger as logger

# ç»“æ„åŒ–æ—¥å¿—
logger.info(
    "User action completed",
    extra={
        "user_id": user.id,
        "action": "create_note",
        "note_id": note.note_id,
        "duration_ms": 150
    }
)

# é”™è¯¯æ—¥å¿—
logger.error(
    "Database connection failed",
    extra={
        "error": str(e),
        "retry_count": retry_count,
        "max_retries": 3
    },
    exc_info=True
)
```

## ğŸ”„ Git Workflow

### Commit Messages
```
feat(backend): add note sharing functionality
fix(frontend): resolve infinite scroll pagination bug
perf(spider): optimize data extraction performance
docs(api): update webhook integration guide
test(notes): add unit tests for note service
chore(deps): update dependencies to latest versions
```

### Branch Naming
- `feature/note-sharing-system`
- `bugfix/pagination-infinite-loop`
- `hotfix/security-vulnerability`
- `docs/api-documentation-update`

---

## ğŸ¯ Key Principles

1. **ç±»å‹å®‰å…¨ç¬¬ä¸€**: ä½¿ç”¨ TypeScript strict mode å’Œ Pydantic ä¸¥æ ¼éªŒè¯
2. **æ€§èƒ½ä¼˜åŒ–**: å¼‚æ­¥ä¼˜å…ˆï¼Œåˆç†ç¼“å­˜ï¼Œé¿å… N+1 æŸ¥è¯¢
3. **ç”¨æˆ·ä½“éªŒ**: å“åº”å¼è®¾è®¡ï¼ŒåŠ è½½çŠ¶æ€ï¼Œé”™è¯¯å¤„ç†
4. **ä»£ç è´¨é‡**: å•å…ƒæµ‹è¯•è¦†ç›–ï¼Œä»£ç å®¡æŸ¥ï¼Œè‡ªåŠ¨åŒ–æ£€æŸ¥
5. **å®‰å…¨æ„è¯†**: è¾“å…¥éªŒè¯ï¼Œæƒé™æ§åˆ¶ï¼Œæ•°æ®åŠ å¯†
6. **æ–‡æ¡£å®Œæ•´**: API æ–‡æ¡£ï¼Œç»„ä»¶æ–‡æ¡£ï¼Œæ¶æ„è¯´æ˜

> æ¯æ¬¡å¼€å‘æ–°åŠŸèƒ½æ—¶ï¼Œè¯·å‚è€ƒä¸Šè¿°è§„åˆ™ç¡®ä¿ä»£ç è´¨é‡å’Œé¡¹ç›®ä¸€è‡´æ€§ã€‚é‡åˆ°ä¸ç¡®å®šçš„æƒ…å†µï¼Œä¼˜å…ˆè€ƒè™‘ç±»å‹å®‰å…¨å’Œç”¨æˆ·ä½“éªŒã€‚